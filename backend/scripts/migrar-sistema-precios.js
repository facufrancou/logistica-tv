/**
 * Script para migrar las listas de precios al nuevo sistema de porcentajes de recargo
 * Tambi√©n actualiza cotizaciones existentes con los nuevos campos
 */

const { PrismaClient } = require('@prisma/client');
const PriceCalculator = require('../src/lib/priceCalculator');

const prisma = new PrismaClient();

// Configuraci√≥n de porcentajes seg√∫n el an√°lisis de las listas existentes
const PORCENTAJES_POR_LISTA = {
  'L15': 15,  // 15% de recargo
  'L18': 18,  // 18% de recargo
  'L20': 20,  // 20% de recargo
  'L25': 25,  // 25% de recargo
  'L30': 30   // 30% de recargo
};

async function migrarListasPrecios() {
  console.log('üìã MIGRANDO LISTAS DE PRECIOS...\n');

  try {
    const listas = await prisma.listaPrecio.findMany();
    
    for (const lista of listas) {
      const porcentajeRecargo = PORCENTAJES_POR_LISTA[lista.tipo] || 0;
      
      console.log(`üè∑Ô∏è  Actualizando ${lista.nombre} (${lista.tipo})`);
      console.log(`   Porcentaje de recargo: ${porcentajeRecargo}%`);
      
      // Actualizar descripci√≥n para reflejar el cambio
      const nuevaDescripcion = `Lista de precios con recargo del ${porcentajeRecargo}%`;
      
      await prisma.listaPrecio.update({
        where: { id_lista: lista.id_lista },
        data: {
          porcentaje_recargo: porcentajeRecargo,
          descripcion: nuevaDescripcion,
          updated_at: new Date()
        }
      });
      
      console.log(`   ‚úÖ Actualizada con ${porcentajeRecargo}% de recargo\n`);
    }
    
    console.log('‚úÖ Migraci√≥n de listas de precios completada\n');
    
  } catch (error) {
    console.error('‚ùå Error en migraci√≥n de listas de precios:', error);
    throw error;
  }
}

async function migrarCotizacionesExistentes() {
  console.log('üíº MIGRANDO COTIZACIONES EXISTENTES...\n');

  try {
    const cotizaciones = await prisma.cotizacion.findMany({
      include: {
        detalle_cotizacion: {
          include: {
            producto: true
          }
        },
        lista_precio: true
      }
    });

    console.log(`üìä Encontradas ${cotizaciones.length} cotizaciones para migrar\n`);

    for (const cotizacion of cotizaciones) {
      console.log(`üíº Migrando cotizaci√≥n ${cotizacion.numero_cotizacion}`);
      
      const porcentajeRecargo = cotizacion.lista_precio?.porcentaje_recargo || 0;
      console.log(`   Lista aplicada: ${cotizacion.lista_precio?.nombre || 'Sin lista'} (${porcentajeRecargo}%)`);
      
      // Migrar cada detalle de cotizaci√≥n
      for (const detalle of cotizacion.detalle_cotizacion) {
        const precioBase = parseFloat(detalle.producto.precio_unitario);
        const precioActual = parseFloat(detalle.precio_unitario);
        
        let precioFinalCalculado = precioBase;
        let porcentajeAplicado = 0;
        
        // Si hay una lista de precios, calcular el precio con recargo
        if (porcentajeRecargo > 0) {
          porcentajeAplicado = porcentajeRecargo;
          precioFinalCalculado = PriceCalculator.calcularPrecioConRecargo(precioBase, porcentajeRecargo);
        } else {
          // Si no hay lista, usar el precio actual como final
          precioFinalCalculado = precioActual;
        }
        
        // Recalcular subtotal
        const nuevoSubtotal = PriceCalculator.calcularSubtotal(precioFinalCalculado, detalle.cantidad_total);
        
        await prisma.detalleCotizacion.update({
          where: { id_detalle_cotizacion: detalle.id_detalle_cotizacion },
          data: {
            precio_base_producto: precioBase,
            porcentaje_aplicado: porcentajeAplicado || null,
            precio_final_calculado: precioFinalCalculado,
            precio_unitario: precioFinalCalculado, // Mantener compatibilidad
            subtotal: nuevoSubtotal,
            facturacion_tipo: 'pendiente',
            editado_manualmente: false
          }
        });
        
        console.log(`     ‚Ä¢ ${detalle.producto.nombre}: $${precioBase} ‚Üí $${precioFinalCalculado} (${porcentajeAplicado}%)`);
      }
      
      // Recalcular precio total de la cotizaci√≥n
      const nuevoPrecioTotal = cotizacion.detalle_cotizacion.reduce((total, detalle) => {
        const precioBase = parseFloat(detalle.producto.precio_unitario);
        let precioFinal = precioBase;
        
        if (porcentajeRecargo > 0) {
          precioFinal = PriceCalculator.calcularPrecioConRecargo(precioBase, porcentajeRecargo);
        }
        
        return total + PriceCalculator.calcularSubtotal(precioFinal, detalle.cantidad_total);
      }, 0);
      
      await prisma.cotizacion.update({
        where: { id_cotizacion: cotizacion.id_cotizacion },
        data: {
          precio_total: nuevoPrecioTotal,
          updated_at: new Date()
        }
      });
      
      console.log(`   üí∞ Precio total actualizado: $${nuevoPrecioTotal}`);
      console.log('   ‚úÖ Cotizaci√≥n migrada\n');
    }
    
    console.log('‚úÖ Migraci√≥n de cotizaciones completada\n');
    
  } catch (error) {
    console.error('‚ùå Error en migraci√≥n de cotizaciones:', error);
    throw error;
  }
}

async function limpiarDatosAntiguos() {
  console.log('üßπ LIMPIANDO DATOS ANTIGUOS...\n');

  try {
    // Como la tabla PrecioPorLista est√° vac√≠a seg√∫n el an√°lisis, 
    // solo necesitamos verificar esto
    const preciosPorLista = await prisma.precioPorLista.count();
    
    if (preciosPorLista > 0) {
      console.log(`‚ö†Ô∏è  Encontrados ${preciosPorLista} registros en PrecioPorLista`);
      console.log('   ‚ùó Considera revisar estos datos antes de eliminarlos');
      
      // Por seguridad, no eliminamos autom√°ticamente
      // await prisma.precioPorLista.deleteMany();
      // console.log('   ‚úÖ Tabla PrecioPorLista limpiada');
    } else {
      console.log('‚úÖ Tabla PrecioPorLista ya est√° vac√≠a');
    }
    
    console.log('‚úÖ Limpieza completada\n');
    
  } catch (error) {
    console.error('‚ùå Error en limpieza de datos:', error);
    throw error;
  }
}

async function verificarMigracion() {
  console.log('üîç VERIFICANDO MIGRACI√ìN...\n');

  try {
    // Verificar listas de precios
    const listas = await prisma.listaPrecio.findMany();
    console.log('üìã LISTAS DE PRECIOS:');
    listas.forEach(lista => {
      console.log(`   ‚Ä¢ ${lista.nombre}: ${lista.porcentaje_recargo}% de recargo`);
    });
    
    // Verificar algunas cotizaciones
    const cotizaciones = await prisma.cotizacion.findMany({
      include: {
        detalle_cotizacion: true,
        lista_precio: true
      },
      take: 3,
      orderBy: { created_at: 'desc' }
    });
    
    console.log('\nüíº COTIZACIONES VERIFICADAS:');
    cotizaciones.forEach(cotizacion => {
      console.log(`   ‚Ä¢ ${cotizacion.numero_cotizacion}:`);
      console.log(`     - Lista: ${cotizacion.lista_precio?.nombre || 'Sin lista'}`);
      console.log(`     - Items: ${cotizacion.detalle_cotizacion.length}`);
      console.log(`     - Total: $${cotizacion.precio_total}`);
      
      const itemsConPorcentaje = cotizacion.detalle_cotizacion.filter(d => d.porcentaje_aplicado > 0).length;
      console.log(`     - Items con recargo: ${itemsConPorcentaje}/${cotizacion.detalle_cotizacion.length}`);
    });
    
    // Estad√≠sticas generales
    const totalCotizaciones = await prisma.cotizacion.count();
    const totalDetalles = await prisma.detalleCotizacion.count();
    const detallesConRecargo = await prisma.detalleCotizacion.count({
      where: { porcentaje_aplicado: { gt: 0 } }
    });
    
    console.log('\nüìä ESTAD√çSTICAS:');
    console.log(`   ‚Ä¢ Total cotizaciones: ${totalCotizaciones}`);
    console.log(`   ‚Ä¢ Total items: ${totalDetalles}`);
    console.log(`   ‚Ä¢ Items con recargo: ${detallesConRecargo}`);
    console.log(`   ‚Ä¢ Items pendientes clasificaci√≥n: ${totalDetalles} (todos)`);
    
    console.log('\n‚úÖ Verificaci√≥n completada');
    
  } catch (error) {
    console.error('‚ùå Error en verificaci√≥n:', error);
    throw error;
  }
}

async function ejecutarMigracionCompleta() {
  console.log('üöÄ INICIANDO MIGRACI√ìN COMPLETA DEL SISTEMA DE PRECIOS\n');
  console.log('='.repeat(60));
  console.log('');

  try {
    await migrarListasPrecios();
    await migrarCotizacionesExistentes();
    await limpiarDatosAntiguos();
    await verificarMigracion();
    
    console.log('\n' + '='.repeat(60));
    console.log('üéâ MIGRACI√ìN COMPLETADA EXITOSAMENTE');
    console.log('');
    console.log('üìã PR√ìXIMOS PASOS:');
    console.log('   1. Ejecutar migraciones de Prisma para aplicar cambios de schema');
    console.log('   2. Probar creaci√≥n de nuevas cotizaciones');
    console.log('   3. Probar clasificaci√≥n fiscal de items');
    console.log('   4. Generar res√∫menes de liquidaci√≥n');
    console.log('   5. Actualizar frontend para nuevas funcionalidades');
    
  } catch (error) {
    console.error('\n‚ùå MIGRACI√ìN FALLIDA:', error);
    console.log('\n‚ö†Ô∏è  RECOMENDACIONES:');
    console.log('   1. Restaurar backup de base de datos');
    console.log('   2. Revisar logs de error');
    console.log('   3. Corregir problemas y reintentar');
  } finally {
    await prisma.$disconnect();
  }
}

// Funci√≥n para ejecutar solo migraci√≥n de listas
async function migrarSoloListas() {
  console.log('üè∑Ô∏è  MIGRANDO SOLO LISTAS DE PRECIOS\n');
  
  try {
    await migrarListasPrecios();
    console.log('‚úÖ Migraci√≥n de listas completada');
  } catch (error) {
    console.error('‚ùå Error:', error);
  } finally {
    await prisma.$disconnect();
  }
}

// Funci√≥n para ejecutar solo migraci√≥n de cotizaciones
async function migrarSoloCotizaciones() {
  console.log('üíº MIGRANDO SOLO COTIZACIONES\n');
  
  try {
    await migrarCotizacionesExistentes();
    console.log('‚úÖ Migraci√≥n de cotizaciones completada');
  } catch (error) {
    console.error('‚ùå Error:', error);
  } finally {
    await prisma.$disconnect();
  }
}

// Ejecutar seg√∫n argumentos de l√≠nea de comandos
if (require.main === module) {
  const comando = process.argv[2];
  
  switch (comando) {
    case 'listas':
      migrarSoloListas();
      break;
    case 'cotizaciones':
      migrarSoloCotizaciones();
      break;
    case 'verificar':
      verificarMigracion().then(() => prisma.$disconnect());
      break;
    default:
      ejecutarMigracionCompleta();
  }
}

module.exports = {
  ejecutarMigracionCompleta,
  migrarListasPrecios,
  migrarCotizacionesExistentes,
  limpiarDatosAntiguos,
  verificarMigracion
};